Λειτουργικά Συστήματα Εργασία 1
Παπαδόπουλος Χρήστος
ΑΜ: 1115202000165

Οδηγίες εκτέλεσης
Για την εκτέλεση χρειάζεται να κληθεί για αρχή η διεργασία ex1_p1.c με ένα path για τη διαμοιραζόμενη μνήμη και, προαιρετικά, ένα όνομα για το αρχείο κειμένου στο οποίο θα γραφούν τα μηνύματα. Σε περίπτωση που ο χρήστης δεν δώσει όνομα αρχείου, για output χρησιμοποιείται το stdout stream. Στη συνέχεια, ο χρήστης θα πρέπει να καλέσει τη διεργασία ex1_p2.c με τα ίδια ορίσματα για να συγχρονιστεί στη δομή μνήμης της πρώτης διεργασίας και στο output stream. Σε περίπτωση λανθασμένης εκτέλεσης από τον χρήστη, εκτυπώνεται ενημερωτικό μήνυμα στο terminal για τη σωστή κλήση της διεργασίας.


Επεξήγηση Κώδικα
Στο  header file ex1.h περιέχονται ένα macro για την εκτύπωση πιθανού σφάλματος στην εκτέλεση των διεργασιών, δύο define για το BUF_SIZE και το TERM_STRING που ολοκληρώνει την εκτέλεση σε περίπτωση που επιθυμεί ο χρήστης να γίνει εύκολα η αλλαγή τους και ο ορισμός της δομής που χρησιμοποιείται για το shared memory segment. Σε αυτό περιέχονται δύο σημαφόροι, το buffer, δύο δομές timeval για την χρονομέτρηση του response time της κάθε διεργασίας και ένα πεδίο FILE* για την ανακατεύθυνση της εξόδου. 
Στα processes ex1_p1.c, ex1_p2.c αρχικοποιούνται global μεταβλητές για τα στατιστικά της ανταλλαγής των μηνυμάτων και γίνεται κατάλληλος ορισμός του output stream ανάλογα με τα ορίσματα του χρήστη. Στο κοινό τους κομμάτι, η κάθε διεργασία αποτελείται από δύο νήματα τα οποία δημιουργούνται και καλούνται στην αρχή του προγράμματος και τρέχουν συνεχόμενα μέχρι να δοθεί σε κάποια από τις δύο διεργασίες μήνυμα με το TERM_STRING και συγχρονίζονται με τους σημαφόρους του shared memory. Πιο συγκεκριμένα, ο sem1 συγχρονίζει τα μηνύματα που στέλνονται από το p1 και λαμβάνονται από το p2 και ο sem2 το ανάποδο. Για να επιτευχθεί αυτό, το receiver thread καλεί στην αρχή του προγράμματος την sem_wait() στον κατάλληλο σημαφόρο ο οποίος έχει τιμή 0 οπότε μπλοκάρει. Όταν δοθεί input από τον χρήστη, το sender thread κάνει sem_post() στον σημαφόρο αυτό και δίνεται access στον receiver. Η εναλλαγή αυτή γίνεται συνεχόμενα αν το μήνυμα είναι μεγαλύτερο από το BUF_SIZE μέσω της fgets() και της fputs(). Για τον συγχρονισμό τους έχει δοθεί ένα μηδαμινό usleep() με διάρκεια 1 microsecond στον sender ώστε να προλάβει ο receiver να παραλάβει το κάθε πακέτο. Σε κάθε πακέτο που αποστέλλεται/παραλαμβάνεται γίνονται increment ο συνολικός αριθμός πακέτου. Ελέγχοντας το κάθε πακέτο για χαρακτήρα “\n” μπορούμε να διαπιστώσουμε αν πρόκεται για το τέλος του μηνύματος και άρα να κάνουμε increment και το συγκεκριμένο στατιστικό. Σε κάθε αρχή νέου μηνύματος που αποστέλλεται καλείται η gettimeofday() και αποθηκεύεται στην αντίστοιχη δομή του shared memory ανάλογα με τον αποστολέα και όταν γίνει η παραλαβή από την άλλη διεργασία καλείται εκ νέου σε μία τοπική μεταβλητή. Η διαφορά των δύο τιμών προστίθεται στην global μεταβλητή των συνολικών response times και στο τέλος διαιρείται με τον αριθμό των μηνυμάτων για να λάβουμε τη μέση τιμή της. 
Επιπλέον, η διεργασία ex1_p1.c είναι υπεύθυνη για την αρχικοποίηση και την αποδέσμευση της διαμοιραζόμενης μνήμης. Για να γίνει αυτό, χρησιμοποιείται μία global μεταβλητή που κρατάει το path της μνήμης. Στην αρχή της διεργασίας, καλείται η shm_open() με το path που έχει δοθεί κατά την εκτέλεση και στη συνέχεια η frtuncate() για να οριστεί το μέγεθος του τμήματος σε αυτό της δομής που έχω φτιάξει. Με τη mmap() κάνουμε map τα δεδομένα στο memStruct variable για να μπορούν να χρησιμοποιηθούν από εκείνη τη διεύθυνση. Στο τέλος της εκτέλεσης, δηλαδή όταν δοθεί από κάποια διεργασία το TERM_STRING, η ex1_p1.c καλεί την shm_unlink() για την αποδέσμευση της μνήμης. Η κλήση της munmap() δεν κρίνεται απαραίτητη καθώς τερματίζει πλήρως η διεργασία. Συνεπώς, αφού η διαμοιραζόμενη μνήμη αρχικοποιείται και αποδεσμεύεται από την ex1_p1, η ex1_p2 χρειάζεται μόνο να αποκτήσει πρόσβαση. Στην αρχή της εκτέλεσης καλεί την shm_open() για την ήδη υπάρχουσα μνήμη, της οποίας η διεύθυνση δίνεται κατά την κλήση, και χωρίς να χρειαστεί ftruncate() καλεί και αυτή την mmap(). Δεν χρειάζεται στο τέλος να κάνει shm_unlink() καθώς αναλαμβάνεται από την ex1_p1.


